#!/usr/bin/env python3
"""Tool to analyze the UTXO set for common output script types and unspendability.

The input UTXO set database for a certain snapshot at height N
can be generated by Bitcoin Core with the following commands:
$ ./build/bin/bitcoin-cli -rpcclienttimeout=0 -named dumptxoutset $PWD/utxos.dat rollback=N
$ ./contrib/utxo-tools/utxo_to_sqlite.py utxos.dat utxos.sqlite3
"""
import argparse
import sqlite3


OP_0 = 0x00
OP_1 = 0x51
OP_DUP = 0x76
OP_EQUAL = 0x87
OP_EQUALVERIFY = 0x88
OP_HASH160 = 0xa9
OP_CHECKSIG = 0xac
OP_CHECKMULTISIG = 0xae


def main():
    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('utxos_sqlite_db', help='path to UTXO dump in SQLite3 format')

    args = parser.parse_args()

    p2pk = 0
    p2pkh = 0
    p2sh = 0
    p2wpkh = 0
    p2wsh = 0
    p2tr = 0
    bare_multisig = 0
    others = 0
    total = 0

    # query utxo set database
    con = sqlite3.connect(args.utxos_sqlite_db)
    cur = con.cursor()
    cur.execute("SELECT * FROM utxos")
    while True:
        row = cur.fetchone()
        if row is None:
            break
        s = bytes.fromhex(row[5])
        # determine output script type (see `Solver` function in Bitcoin Core)
        if len(s) == 23 and s[0] == OP_HASH160 and s[1] == 20 and s[22] == OP_EQUAL:
            p2sh += 1
        elif len(s) == 22 and s[0] == OP_0 and s[1] == 20:
            p2wpkh += 1
        elif len(s) == 34 and s[0] == OP_0 and s[1] == 32:
            p2wsh += 1
        elif len(s) == 34 and s[0] == OP_1 and s[1] == 32:
            p2tr += 1
        elif len(s) == 67 and s[0] == 65 and s[66] == OP_CHECKSIG:
            p2pk += 1
        elif len(s) == 35 and s[0] == 33 and s[34] == OP_CHECKSIG:
            p2pk += 1
        elif len(s) == 25 and s[0] == OP_DUP and s[1] == OP_HASH160 and \
             s[2] == 20 and s[23] == OP_EQUALVERIFY and s[24] == OP_CHECKSIG:
            p2pkh += 1
        elif s[-1] == OP_CHECKMULTISIG:  # TODO: refine that check and extract pubkeys
            bare_multisig += 1
        else:
            others += 1

        # TODO: import secp256k1.py module from Bitcoin Core test framework and use it to
        #       identify provably unspendable coins (possible if a pubkey is directly
        #       in the output script, i.e. for P2PK, bare multisig and P2TR)

        total += 1
        if total % 10_000_000 == 0:
            print(f"{total//1_000_000} million UTXOs processed...")
    con.close()

    # TODO: maybe display sorted by count in descending order (i.e. most relevant first)
    print()
    print( "Results:")
    print( "-----------------------------------")
    print(f"P2PK:          {p2pk:>10}, {p2pk/total*100:.2f}%")
    print(f"P2PKH:         {p2pkh:>10}, {p2pkh/total*100:.2f}%")
    print(f"P2SH:          {p2sh:>10}, {p2sh/total*100:.2f}%")
    print(f"P2WPKH:        {p2wpkh:>10}, {p2wpkh/total*100:.2f}%")
    print(f"P2WSH:         {p2wsh:>10}, {p2wsh/total*100:.2f}%")
    print(f"P2TR:          {p2tr:>10}, {p2tr/total*100:.2f}%")
    print(f"bare multisig: {bare_multisig:>10}, {bare_multisig/total*100:.2f}%")
    print(f"others:        {others:>10}, {others/total*100:.2f}%")
    print( "-----------------------------------")
    print(f"Total UTXOs:   {total:>10}")


if __name__ == "__main__":
    main()
