#!/usr/bin/env python3
"""Tool to create a binary-encoded hints file for the "IBD-Booster" proposal.

The resulting data is a bit-vector of all transaction outputs ever created
up to block number N, where each bit indicates the answer to the question
"Is this transaction output part of the UTXO set at block height N?".

The input UTXO set database for a certain snapshot at height N
can be generated by Bitcoin Core with the following commands:
$ ./build/bin/bitcoin-cli -rpcclienttimeout=0 -named dumptxoutset $PWD/utxos.dat rollback=N
$ ./contrib/utxo-tools/utxo_to_sqlite.py utxos.dat utxos.sqlite3
$ sqlite3 utxos.sqlite3 "CREATE INDEX idx_height ON utxos (height)"
"""
import argparse
from pathlib import Path
import sqlite3
import sys

from bitcoin_primitives import CBlock, from_binary
import pbk


class HintsWriter:
    def __init__(self, file):
        self.file = file

    def write_block_bits(self, bitmap):
        # for each block, write first the number of outputs it contains
        # and then the bit-encoded data (padded with zero-bits if necessary)
        writebuf = b''
        writebuf += len(bitmap).to_bytes(2, 'big')
        bitpos = 0
        value = 0
        for bit in bitmap:
            value = (value << 1) | bit
            bitpos += 1
            if bitpos == 8:
                writebuf += bytes([value])
                bitpos = 0
                value = 0
        if bitpos != 0:
            writebuf += bytes([value])
        self.file.write(writebuf)


def main():
    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('utxos_sqlite_db', help='path to UTXO dump in SQLite3 format (should contain a block height index for fast processing)')
    parser.add_argument('node_datadir', help='path to bitcoin data directory (must be from a non-pruned node)')
    parser.add_argument('output_hints_file', help='filename of created booster hints file')
    parser.add_argument('-v', '--verbose', action='store_true', help='show more detailed conversion stats on each block')
    args = parser.parse_args()

    if not Path(args.utxos_sqlite_db).exists():
        print(f"Error: provided input file '{args.utxos_sqlite_db}' doesn't exist.")
        sys.exit(1)

    if not Path(args.node_datadir).exists():
        print(f"Error: provided input directory '{args.node_datadir}' doesn't exist.")
        sys.exit(1)

    if Path(args.output_hints_file).exists():
        print(f"Error: provided output file '{args.output_hints_file}' already exists.")
        sys.exit(1)

    #log = pbk.LoggingConnection()

    # open utxo set, determine snapshot height
    con = sqlite3.connect(args.utxos_sqlite_db)
    cur = con.cursor()
    cur.execute("SELECT max(height) from utxos")
    snapshot_height = cur.fetchone()[0]
    print(f"UTXO snapshot is at block height {snapshot_height}.")

    # TODO: make node_datadir arg optional and set it to this if none is set:
    #datadir = Path.home() / ".bitcoin"
    datadir = Path(args.node_datadir)
    print("Loading chain manager... ", end='', flush=True)
    # TODO: allow specifying the chaint type (unfortunately, the UTXO db doesn't contain that as metadata yet :/)
    #chainman = pbk.load_chainman(datadir, pbk.ChainType.MAINNET)
    chainman = pbk.load_chainman(datadir, pbk.ChainType.SIGNET)
    print("done.")

    print("Open output hints file... ", end='', flush=True)
    hints_file = open(args.output_hints_file, 'wb')
    hints_writer = HintsWriter(hints_file)

    for block_height in range(0, snapshot_height+1):
        block_index = chainman.get_block_index_from_height(block_height)
        block_data = chainman.read_block_from_disk(block_index).data
        #print(block_data)
        block = from_binary(CBlock, block_data)
        assert block.is_valid()  # TODO: only do this in a 'thorough' mode
        outputs_bitmap = []
        outputs_in_utxo_set = 0
        for tx in block.vtx:
            txid = tx.rehash()
            cur.execute("SELECT vout FROM utxos WHERE height=? and txid=?", (block_height, txid))
            outs_in_utxoset = [o[0] for o in cur.fetchall()]
            if len(outs_in_utxoset) == 0:
                outputs_bitmap.extend([0] * len(tx.vout))
                continue

            for out_idx, txout in enumerate(tx.vout):
                if out_idx in outs_in_utxoset:
                    print(block_height, out_idx, txout)
                    outputs_bitmap.append(1)
                    outputs_in_utxo_set += 1
                else:
                    outputs_bitmap.append(0)

        hints_writer.write_block_bits(outputs_bitmap)
        print(f"Block {block_height} has {outputs_in_utxo_set} outputs in UTXO set.")

    con.close()
    hints_writer.close()


if __name__ == "__main__":
    main()
